package com.remixlang.examples.chat

export Chat

type Chat = component
  hasA Console withA NodeStdio
  hasA MockClient

type RawStdio = abstract component
  port io
    output fromStdin :: String
    input toStdout :: String

type NodeStdio = RawStdio => component

  daemon [javaScript fromStdin|
     process.stdin.resume();
     process.stdin.setEncoding('utf8');

     process.stdin.on('data', function (chunk) {
       fromStdin(chunk);
     });
    |]

  port io
    on toStdout [javascript toStdout|
        process.stdout.write(toStdout);
      |]

type Console = component
  hasA RawStdio

  var partialLine := ""

  port rawIo
    input fromStdin :: String
    output toStdout :: String

    on fromStdin
      if not fromStdin.empty then
        var lines := fromStdin.split (regex "\n")
        lines[0] := partialLine ++ lines[0]
        n = lines.length
        trailingNewline = fromStdin.endsWith "\n"
        partialLine := ""
        for i <- 0..n yield do
          if i < n-1 || trailingNewline then
            console.fromStdin := lines[i]
          else
            partialLine := lines[i]

  port console
    output fromStdin :: String
    input toStdout :: String

    on toStdout
      rawIo.toStdout := toStdout

type ChatClient = abstract component
  port commands
    input command :: String
    output response :: String

type MockClient = ChatClient => component
  historyLength = 10
  
  var history := emptyChatHistory historyLength

  port commands
    on command
      case parseVerb command of
        Some "help" ->
          response :=
            [stringWithNewlines
             | ":history" shows chat history.
             | ":clear" clears chat history.
             |
             | "!xyz" repeats the most recent command that started with "xyz".
             | "?xyz" repeats the most recent command that contained "xyz".
             |      (These can include punctuation such as ":".)
             |
             | Anything else is a message to be sent into the chat.
             |]
        Some "history" ->
          response := history.prettyPrint
        Some "clear" ->
          history .= clear
          response := "History cleared."
        _ ->
          response := if command.startsWith "!" then
            processCommand history.findMostRecentMatching (regex $ "^%s" format response[1..])
          else if command.startsWith "?" then
            processCommand history.findMostRecentMatching response[1..]
          else
            processCommand command
          
      history .= add $ Interaction command response

type ChatHistory = PrettyPrintable => object
  length :: Int
  history :: [HistoryElement]
  
  add :: HistoryElement -> ChatHistory
  add e =
    if history.length >= length then
      history .= tail
    history += e

  clear :: ChatHistory
  clear = this { history = [] }

  prettyPrint = history.map prettyPrint .join "\n\n"

  -- Intentionally demonstrating some language features here, although an abstract method would be prettier.
  findMostRecentMatching :: (String | Regex) -> Boolean
  findMostRecentMatching pat = history.reverse.find $ matches pat
                               where matches rx elt = case cast elt of
                                 Just interaction -> interaction.command.contains pat
                                 _ -> false

emptyChatHistory :: Int -> ChatHistory 
emptyChatHistory length = ChatHistory
  length = length
  history = []

type PrettyPrintable = abstract object
  prettyPrint :: String

type HistoryElement = PrettyPrintable => abstract

type Interaction = HistoryElement => object
  command :: String
  Response :: String

  prettyPrint = "Command:  " ++ command ++ "\n" ++
                "Response: " ++ response
