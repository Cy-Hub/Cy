module staq.examples.chat.mockclient

export (mockClientBlueprint)

-- A blueprint can be declared in code like this, or constructed dynamically as a Blueprint object.
-- The intent is to allow an IDE to construct a Blueprint, which can be saved or instantiated.

mockClientBlueprint = blueprint
  has 1 console :: LineIo
  has 1 stdio :: NodeStdio
  has 1 mockClient :: MockClient

  -- The parameter order on a wire doesn't matter.  The runtime will look for a typesafe set
  -- of connections between inputs and outputs, and complain if there is not exactly one.
  
  wire mockClient.commands console.lineIo 
  wire console.rawIo stdio.io

type MockClient = component

  var history := ChatHistory

  port commands
    input command :: String >> String handles
      c ->
        -- We pointlessly delegate handling of this command to the processCommand action, to show how
        -- actions are declared and used.  The body of processCommand could instead appear here.
      
        -- Neither this variable nor its type declaration are required, but they show what is going on.
        -- The processCommand action will occur asynchronously to this action.
        
        answer :: Future String
        answer = send processCommand c

        -- Since this input handler returns a Future String, the runtime will wait for the String reply
        -- to come back from processCommand and send it back as our reply.
        
        answer        

    action processCommand :: String >> String handles
      c ->
        answer = case parseVerb c of
          Some "help" ->
              [stringLines
               | ":history" shows chat history.
               | ":clear" clears chat history.
               |
               | "!xyz" repeats the most recent command that started with "xyz".
               | "?xyz" repeats the most recent command that contained "xyz".
               |      (These can include punctuation such as ":".)
               |
               | Anything else is a message to be sent into the chat.
               |]
          Some "history" ->
            history.prettyPrint
          Some "clear" ->
            history .= clear
            "History cleared."
          _ ->
            if c.startsWith "!" then
              processCommand history.chFindMostRecentMatching (_.startsWith response[1..])
            else if c.startsWith "?" then
              processCommand history.chFindMostRecentMatching (_.contains response[1..])
            else
              processCommand c
              
        history .= chAdd $ Interaction command answer
        answer
      
{- Declaring a type Foo to be an object defines two new identifiers:
   * A type constructor Foo, which may take type parameters.
   * A value constructor Foo, which may take value parameters.
 -}

type ChatHistory = object

  -- This is actually a method; its full type is ChatHistory -> Int.
  private chMaxLength = 10
  
  private var chElements := [] :: HistoryElement a => [a] 

  chAdd :: HistoryElement -> ChatHistory
  chAdd e =
    if length chElements >= chMaxLength then -- we could equivalently write chElements.length
      chElements .= tail -- shorthand for chElements := chElements.tail
    chElements += e

  -- Returns a copy of this ChatHistory with chElements set back to the empty list.
  chClear :: ChatHistory
  chClear =
    chElements := []

  -- Intentionally showing how the method invocation syntax for `map` is different from OO languages.
  chPrettyPrint = join "\n\n" $ prettyPrint.map chElements

  chFindMostRecentSatisfying :: (HistoryElement -> Boolean) -> Boolean
  chFindMostRecentSatisfying pred = history.reverse.find pred

{- An interface is equivalent to a Haskell type class.  An interface is specified as a set of top-level
   functions that must each have a type that mentions the target type (`a` in the example below).
 -}

interface PrettyPrintable a where
  prettyPrint :: a -> String

{- An interface implementation is always declared externally from the definition of the object.
   When a method should be used as the implementation of an interface function, the interface function
   is simply declared equal to the method.
 -}

implementation PrettyPrintable ChatHistory where
  prettyPrint = chPrettyPrint

{- An interface declaration with no where clause just provides a new name for an existing interface.
   In this example, HistoryElement is a new interface, but the implementation of HistoryElement for a
   type doesn't have to do anything; it just needs to be declared.
 -}

interface PrettyPrintable a => HistoryElement a 

type Interaction = object
  var command :: String
  var response :: String

implementation PrettyPrintable Interaction where
  prettyPrint = "Command:  " ++ command ++ "\n" ++
                "Response: " ++ response

-- Since Interaction already has the PrettyPrintable interface, we can simply declare it to have
-- the HistoryElement interface.

implementation HistoryElement Interaction
