package staq.examples.chat

export (MockClient)

-- A component may have subcomponents, wiring, ports, event handlers, and state (vars).

type MockClient = component
  var history := ChatHistory

  port commands
    output response :: String
    
    input command :: String of
      c -> case parseVerb c of
             Some "help" ->
               response :=
                 [stringLines
                  | ":history" shows chat history.
                  | ":clear" clears chat history.
                  |
                  | "!xyz" repeats the most recent command that started with "xyz".
                  | "?xyz" repeats the most recent command that contained "xyz".
                  |      (These can include punctuation such as ":".)
                  |
                  | Anything else is a message to be sent into the chat.
                  |]
             Some "history" ->
               response := history.prettyPrint
             Some "clear" ->
               history .= clear
               response := "History cleared."
             _ ->
               response := if c.startsWith "!" then
                 processCommand history.chFindMostRecentMatching (_.startsWith response[1..])
               else if c.startsWith "?" then
                 processCommand history.chFindMostRecentMatching (_.contains response[1..])
               else
                 processCommand c
          
      history .= chAdd $ Interaction command response

      
{- The object model is extremely simple:

    * There is no subclassing or inheritance. This is to avoid the complexity of covariance, of type inference
      in the face of subclassing, etc. We aren't just being lazy; that complexity would spill over into the
      programmer's mental model and into error messages.

    * Objects are immutable.
 -}

{- Declaring a type Foo to be an object defines two new identifiers:
   * A type constructor Foo, which may take type parameters.
   * A value constructor Foo, which may take value parameters.
 -}

type ChatHistory = object

  -- This is actually a method; the full type of chMaxLength is ChatHistory -> Int.
  private chMaxLength = 10
  
  private var chElements := [] :: HistoryElement a => [a] 

  {- Method names do not live in a "class-local namespace".  They must be unique.
     The reason for this is that we prefer using type inference (method and function names imply type)
     instead of explicitly declaring types and using that to disambiguate names.  Also, this keeps
     type inference very direct and simple, which makes error messages relatively easy to understand.

     Methods, however, do have a one special privilege, plus some notational convenience.

     The special privilege is that methods can access private fields.

     The notational convenience is that a method
       * takes a copy of the object on which it was invoked as an implicit first lvalue parameter;
       * implicitly modifies that lvalue when it updates fields of the object;
       * and implicitly returns that lvalue if it is declared to return the object's own type,
         and if it ends with a statement instead of an expression.
       * Plus, this implicit behavior extends to a method that invokes another method: the implicit
         `this` lvalue is passed to the invoked method, and if that method returns a value of the same
         type, the `this` lvalue is updated in the caller.

     When a method is used from outside the declaring object, or when applying a function declared at the top
     level, method invocation syntax (a.foo b) or application syntax (foo a b) may be used
     interchangeably. However, when invoking one method from inside another in the same object declaration,
     method invocation syntax (foo b, with an implicit `this` as a) must be used.
   -}
  
  chAdd :: HistoryElement -> ChatHistory
  chAdd e =
    if length chElements >= chMaxLength then -- we could equivalently write chElements.length
      chElements .= tail -- shorthand for chElements := chElements.tail
    chElements += e

  -- Returns a copy of this ChatHistory with chElements set back to the empty list.
  chClear :: ChatHistory
  chClear =
    chElements := []

  -- Intentionally showing how the method invocation syntax for `map` is different from OO languages.
  chPrettyPrint = join "\n\n" $ prettyPrint.map chElements

  chFindMostRecentSatisfying :: (HistoryElement -> Boolean) -> Boolean
  chFindMostRecentSatisfying pred = history.reverse.find pred

{- An interface is equivalent to a Haskell type class.  An interface is specified as a set of top-level
   functions that must each have a type that mentions the target type (`a` in the example below).
 -}

interface PrettyPrintable a where
  prettyPrint :: a -> String

{- An interface implementation is always declared externally from the definition of the object.
   When a method should be used as the implementation of an interface function, the interface function
   is simply declared equal to the method.
 -}

implementation PrettyPrintable ChatHistory where
  prettyPrint = chPrettyPrint

{- An interface declaration with no where clause just provides a new name for an existing interface.
   In this example, HistoryElement is a new interface, but the implementation of HistoryElement for a
   type doesn't have to do anything; it just needs to be declared.
 -}

interface PrettyPrintable a => HistoryElement a 

type Interaction = object
  var command :: String
  var response :: String

implementation PrettyPrintable Interaction where
  prettyPrint = "Command:  " ++ command ++ "\n" ++
                "Response: " ++ response

-- Since Interaction already has the PrettyPrintable interface, we can simply declare it to have
-- the HistoryElement interface.

implementation HistoryElement Interaction
